;Author: Aliaa Gheis
;DATE:
;This Progam
;======================
;======================

                ;       0    1    2    3    4    5    6    7        rows
                ;  0    0    1    2    3    4    5    6    7
                ;  1    8    ............................ 15
                ;  2    16   ...............................
                ;  3    24 ..................................
                ;  4    32 ..................................   
                ;  5    40 ..................................
                ;  6    48 ..................................
                ;  7    56..............................  63
                ;==================================================
                ;TODO
                ;- don't draw another player move => miss things up
                ;- exit for both on click f4

        PUBLIC StartGame, RowColToCell, CellToRowCol, RowColToStartPos
        PUBLIC kingsCells, kingsRows, kingsCols, playersState, isGameEnded
        PUBLIC boardWidth, imageWidth, color, board, Bpawn, validateMoves, highlightPeiceMvs 
        PUBLIC playerCells, playerCols, playerRows, PlayerPos, highlightColor, PlayerSelectedCell,PlayerSelectedRow, PlayerSelectedPos
        EXTRN DrawBoard:FAR
        EXTRN DrawSquareBord:FAR
        EXTRN DrawSquareBordSm:FAR
        EXTRN MvePlayerFromGraphics:FAR
        EXTRN DrawHighlightedMvs:FAR
        EXTRN ClrHighlightedMvs:FAR
        EXTRN MvePieceToGraphics:FAR
        EXTRN MvePieceFromGraphics:FAR
        EXTRN DrawPlayers:FAR

        EXTRN AddPeiceToAnimationQueue:FAR
        EXTRN StartAnimation:FAR

        EXTRN killedPeicePos:WORD
        EXTRN PlayerGameNumber:WORD
        EXTRN killedPeiceRow:BYTE
        EXTRN killedPeiceCol:BYTE
        
        EXTRN playerWinGame:BYTE
        EXTRN player1:BYTE
        EXTRN player2:BYTE
        

        
        .286
        .MODEL HUGE
        .STACK 256
.DATA
        activePage equ 3
        ;======= chat
        ValueForchat DB '$$'
        msg1 DB 'Me: $'
        msg2 DB 'You: $'
        keypressed db ?
        
        c1 DW 0
        c2 DW 0400h
        startCol db 23
        rowSize db 40

        stausLineRow equ 7      ;endRow-2 => 
                                ;line sepreate status from chat
        
        ChatLineRow equ  3      ;line seperate two chats
                                ;(end-start)/2
                                ;start = 0
        PlayerSentMessState     equ 64
        ;==== chat
;_______sending&recieving__________;

from_against_player db '$'
to_against_player db '$'
;__________Peices________;

        color          db  31, 9
        highlightColor equ 72
        highlightPeiceMvs db ?, 64, 80
        boardWidth     equ 23
        imageWidth     equ 23
        ; ____ game time _____ ;
        GameMin        equ 3
        GameSec        equ 0
        StartMin        db ?
        StartSec        db ?
        ; ____ game peice ____ ;
        emptyCell      equ 0
        pawn           equ 1
        rook           equ 2
        knight         equ 3
        bishop         equ 4
        queen          equ 5
        king           equ 6 
        ; ____ peice color ____ ;
        black          equ 8
        white          equ 0
        ; ____ peice mask ____ ;
        peice          equ 7
        
        ;____ players _____;
        playerNum1         equ 1
        playerNum2         equ 2


        PlayerClkF4             equ 128
        playerMoveToChoosePeice equ 0
        playerMoveToChooseAction equ 1
        PlayerLose equ 2
        PlayerWin equ 3
        PlayerEndedGame equ 4

        isGameEnded db 0 ;1 => game ended & 2 game ended by player
        
        isKingCheck db ?, 0, 0
        playersState db ?, playerMoveToChoosePeice, playerMoveToChoosePeice
        playerCells db ?, 0, 56
        playerRows  db ?, 0, 7
        playerCols  db ?, 0, 0
        PlayerPos   dw ?, 0, 51520

        kingsCells db ?, 4, 60
        kingsRows  db ?, 0, 7
        kingsCols  db ?, 4, 4


        PlayerSelectedCell  db ?, ?, ?
        PlayerSelectedRow  db ?, ?, ?
        PlayerSelectedPos  dw ?, ?, ?


        lstValidDirection dw 8 dup(?);

        validateMoves db 64 dup(0)
        validateMovesTemp db 64 dup(0)


        ; ____ board ____ ;
        board          db  rook+black, knight+black, bishop+black, queen+black, king+black, bishop+black, knight+black, rook+black
                       db  8 dup(pawn+black)
                       db  4 dup(8 dup(emptyCell))
                       db  8 dup(pawn)
                       db  rook, knight, bishop, queen, king, bishop, knight, rook
        peiceTimer     dw  64 dup(0)
        TmDiff equ 3
        ; _____Important Position ______;
        checkmes db      "be carefull there  is a check$"
        Clearcheckmes db '                              $'
        player1WinMess  db " Win!!", 1h, '$'
        player2WinMess  db " Loss!! $"
        prntExitMess  db "click f4 to exit the game $"

        timerArray dw 33 dup(0);[row,[4]col[4]] than have still time
                                ;to print
        headTimeArray db 0
        tailTimeArray db 0
         VALUE DB '$$'

Bpawn DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Wpawn DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Brook DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 4, 16, 16, 16, 16, 4, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Wrook DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 4, 16, 16, 16, 16, 4, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 15, 15, 16, 16, 15, 15, 15, 16, 16, 16, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Bknight DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 4, 4, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 16, 4, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 4, 16, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Wknight DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 4, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 15, 15, 15, 15, 15, 15, 15, 16, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 16, 16, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 15, 15, 15, 15, 15, 15, 16, 16, 16, 15, 15, 15, 15, 15, 15, 16, 4, 4, 4, 4
 DB 4, 16, 16, 16, 15, 15, 15, 15, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 16, 16, 15, 15, 15, 15, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Bbishop DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 15, 15, 15, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Wbishop DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 15, 15, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 16, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 16, 16, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Bqueen DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 4, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4
 DB 16, 16, 16, 16, 16, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4
 DB 16, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 16, 4, 4
 DB 16, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 16, 16, 16, 16, 4, 16, 16, 16, 4, 4, 4
 DB 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 15, 15, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 15, 15, 15, 15, 16, 16, 16, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Wqueen DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 16, 16, 4, 4, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 4, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 16, 16, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 16, 16, 4, 4, 4
 DB 16, 16, 16, 16, 16, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4
 DB 16, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 16, 4, 4
 DB 16, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 4, 16, 16, 16, 16, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 16, 15, 16, 16, 15, 16, 16, 15, 15, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 15, 16, 16, 15, 16, 16, 15, 15, 16, 15, 15, 16, 15, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 15, 16, 16, 15, 16, 16, 16, 16, 16, 15, 16, 16, 15, 16, 16, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 15, 15, 15, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Bking DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 16, 16, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 15, 15, 15, 15, 16, 4, 4, 4, 4
 DB 4, 16, 15, 15, 16, 16, 16, 15, 15, 16, 16, 16, 15, 15, 16, 16, 16, 16, 15, 16, 4, 4, 4
 DB 4, 16, 15, 16, 16, 16, 16, 16, 16, 15, 16, 15, 16, 16, 16, 16, 16, 16, 15, 16, 4, 4, 4
 DB 4, 16, 15, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 16, 16, 16, 16, 15, 16, 4, 4, 4
 DB 4, 16, 15, 16, 16, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 16, 16, 15, 16, 4, 4, 4
 DB 4, 4, 16, 15, 16, 16, 16, 16, 16, 16, 15, 16, 16, 16, 16, 16, 16, 15, 16, 16, 4, 4, 4
 DB 4, 4, 16, 16, 15, 15, 15, 15, 15, 16, 16, 16, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 15, 15, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 15, 15, 15, 15, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 15, 15, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 15, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 15, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4



Wking DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4 
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 16, 16, 15, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 15, 15, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 16, 16, 16, 15, 15, 16, 16, 16, 15, 15, 16, 16, 16, 15, 15, 16, 16, 16, 4, 4, 4
 DB 4, 16, 16, 15, 15, 15, 15, 15, 16, 16, 15, 15, 16, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 16, 16, 15, 15, 15, 15, 15, 15, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 4, 4, 4
 DB 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 15, 15, 15, 15, 15, 15, 15, 15, 16, 4, 4, 4
 DB 4, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 15, 15, 15, 15, 15, 15, 15, 16, 16, 4, 4, 4
 DB 4, 4, 16, 16, 15, 15, 15, 15, 15, 15, 16, 15, 15, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4
 DB 4, 4, 4, 16, 16, 16, 16, 16, 16, 15, 15, 15, 16, 16, 16, 15, 16, 16, 16, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 15, 15, 16, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 15, 15, 16, 16, 16, 16, 16, 15, 15, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 16, 16, 16, 16, 16, 15, 15, 15, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 16, 16, 16, 16, 16, 16, 16, 16, 16, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4
 DB 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4        

.code


port_initializatiion PROC FAR
        pusha 
        mov dx,3fbh ; Line Control Register
        mov al,10000000b ;Set Divisor Latch Access Bit
        out dx,al 
        mov dx,3f8h
        mov al,0ch
        out dx,al
        mov dx,3f9h
        mov al,00h
        out dx,al
        mov dx,3fbh
        mov al,00011011b
        out dx,al
        popa
        ret
port_initializatiion EndP
SEND            PROC
                pusha
                mov dx , 3FDH 
        AG:     in al, dx       ;Read Line Status
                AND al , 00100000b
                JZ AG
                mov dx , 3F8H ; Transmit data register
                mov al,VALUE
                out dx , al 
                popa
                RET
SEND            ENDP



EndGameState    PROC FAR

                
        ;========= inialize board =========;
                mov cx, 64      ;clear board
                mov si, 0
                mov di, 0
        inializeBoard:  mov board[si], 0
                mov peiceTimer[di], 0;dw
                mov validateMoves[si], 0
                inc si
                add di, 2
                loop inializeBoard

                mov board[0], black+rook
                mov board[1], black+knight
                mov board[2], black+bishop
                mov board[3], queen+black
                mov board[4], king+black
                mov board[5], bishop+black
                mov board[6], knight+black
                mov board[7], rook+black

                mov board[8], black+pawn
                mov board[9], black+pawn
                mov board[10], black+pawn
                mov board[11], black+pawn
                mov board[12], black+pawn
                mov board[13], black+pawn
                mov board[14], black+pawn
                mov board[15], black+pawn

                mov board[48], pawn
                mov board[49], pawn
                mov board[50], pawn
                mov board[51], pawn
                mov board[52], pawn
                mov board[53], pawn
                mov board[54], pawn
                mov board[55], pawn
                ;
                mov board[56], rook
                mov board[57], knight
                mov board[58], bishop
                mov board[59], queen
                mov board[60], king
                mov board[61], bishop
                mov board[62], knight
                mov board[63], rook
        ;============= in
                mov isGameEnded, 0
                mov playersState[1], playerMoveToChoosePeice
                mov playersState[2], playerMoveToChoosePeice

                mov playerCells[1], 0
                mov playerCells[2], 56

                mov playerRows[1], 0
                mov playerRows[2], 7

                mov playerCols[1], 0
                mov playerCols[2], 0

                mov PlayerPos[2], 0
                mov PlayerPos[4], 51520
                ;======= king and check
                mov isKingCheck[1], 0
                mov isKingCheck[2], 0
                mov kingsCells[1], 4
                mov kingsCells[2], 60
                mov kingsRows[1], 0
                mov kingsRows[2], 7
                mov kingsCols[1], 4
                mov kingsCols[2], 4
        ;========================================
                mov killedPeicePos, 20664
                mov killedPeiceRow, 0 
                mov killedPeiceCol, 0 

        RET
EndGameState    ENDP




RowColToCell    PROC FAR ;al = row  cl = col  =>> si = CellNumber
                push ax
                push bx
                mov bl,8
                mul bl  ; al = al*8
                add al, cl ; al = al*8 + col

                sub ah, ah
                mov si, ax

                pop bx
                pop ax
                RET
RowColToCell ENDP 

RowColToStartPos PROC   FAR ;al =row    cl=col   =>di=StartPos

        push ax
        push bx
        push cx
        push dx

        mov ah,0
        mov di,ax
        mov al,boardWidth       ;al = width|hight
        mul cl                  ;al = width*col
        mov bx,ax               ;bx = width*col

        mov dx,0
        mov ax,320*boardWidth   ;ax=320*hight
        mul di                  ;ax=320*hight*row


        mov di,ax               ;di=320*row*hight
        add  di,bx              ;di=320*row*hight+width*col

        pop dx       
        pop cx       
        pop bx       
        pop ax       
        RET
RowColToStartPos ENDP 


;________ __________ ___________;
;________ __________ ___________;
;________ validators ___________;
;________ __________ ___________;
;________ __________ ___________;
GetPlayerColorV2 Proc   FAR; si = player   ; cl=piece    ;ch =output 
                push si
                ;for empty cell
                cmp cl,emptyCell
                je result
                ; if si =1 => 8  || si = 2 =>0
                and si ,1
                shl si, 3
                and cl ,black
                mov ch,0
                ;compare if the color is the same
                cmp cx,si 
                jne result

                mov cx, 0
                pop si
                RET
                


        result: pop si
                mov cx,si
                
ret
GetPlayerColorV2 Endp

;** si = peice
GetPlayerColor Proc far  ; si = player   ; cl =color
                push si
                shr si,3;si = color            
                and si,1;si = color => make sure   
                mov ch,0
                mov cx,si;cx => 0 => white || 1 =>
                pop si
    ret
GetPlayerColor Endp

ispeice Proc  FAR; si = palyer ; dl = 1 if piece and 0 if not piece
                push si
                and si ,peice
                shl si,5
                jnz PeiceExist
                mov dl,0 
                jmp Ex
                PeiceExist:
                mov dl,1
                Ex:
                pop si
    ret
ispeice Endp
; === helpers
ValidatePawn    PROC FAR  ;al = row cl = col si = player di = cell
                pusha
                mov bh, 0
                mov dx, si 
                mov ah, 0
                mov al, playerCells[si]
                mov di, ax
                ;===== for valid players ====;
                cmp si, 1 ;chk if player black
                jne PaP2

        PaP1:           cmp playerRows[si], 7
                        je EXITPP1
                PwnMv1: ;down one if
                        mov al, board[di+8]
                        cmp al, emptyCell
                        jne PwnMv3                      ;skip down twice if not valid
                        mov validateMoves[di+8], dl
                PwnMv2: ;down twice if
                        cmp playerRows[si], 1           ;down twice in first move
                        jne PwnMv3
                        mov al, board[di+16]
                        cmp al, emptyCell
                        jne PwnMv3
                        mov validateMoves[di+16], dl
                        

                PwnMv3: ;right down
                        cmp PlayerCols[si], 7
                        je PwnMv4
                        mov al, board[di+9]
                        cmp al, emptyCell
                        je PwnMv4
                        shr al, 3               ;get color bit
                        cmp al, 0               ;check if white
                        jne PwnMv4
                        mov validateMoves[di+9], dl
                        mov lstValidDirection[0], di    ;for check
                        add lstValidDirection[0], 9

                PwnMv4: ;right down
                        cmp PlayerCols[si], 0
                        mov al, board[di+7]
                        cmp al, emptyCell
                        je EXITPP1
                        shr al, 3               ;get color bit
                        cmp al, 0               ;check if white
                        jne EXITPP1
                        mov validateMoves[di+7], dl
                        mov lstValidDirection[2], di    ;for check
                        add lstValidDirection[2], 7
                EXITPP1:
                POPA
                RET
        PaP2:           cmp playerRows[si], 0
                        je EXITPP2
                PwnMv12: ;up one if
                        mov al, board[di-8]
                        cmp al, emptyCell
                        jne PwnMv32
                        mov validateMoves[di-8], dl
                        
                PwnMv22:;up twice if
                        cmp playerRows[si], 6          ;up twice in first move
                        jne PwnMv32
                        mov al, board[di-16]
                        cmp al, emptyCell
                        jne PwnMv32
                        mov validateMoves[di-16], dl

                PwnMv32: ;down -> left
                        cmp PlayerCols[si], 0
                        je PwnMv42
                        mov al, board[di-9]
                        cmp al, emptyCell
                        je PwnMv42
                        shr al, 3               ;get color bit
                        cmp al, 1               ;check if white
                        jne PwnMv42
                        mov validateMoves[di-9], dl

                        mov lstValidDirection[0], di    ;for check
                        sub lstValidDirection[0], 9
                PwnMv42: ;right down
                        cmp PlayerCols[si], 7
                        mov al, board[di-7]
                        cmp al, emptyCell
                        je EXITPP2
                        shr al, 3               ;get color bit
                        cmp al, 1               ;check if white
                        jne EXITPP2
                        mov validateMoves[di-7], dl
                        mov lstValidDirection[2], di    ;for check
                        sub lstValidDirection[2], 7
                EXITPP2:
                popa
                RET     
ValidatePawn    ENDP

ValidateRook    Proc ;al = row cl = col si = player di = cell
                pusha

                
                mov ax, 0
                mov al, playerCells[si]
                mov di, ax 

                mov al, playerRows[si] 
                mov cl, playerCols[si]
                
                push cx
                push si
                mov cl,board[di]
                mov ch,0
                mov si,cx
                Call GetPlayerColor  ; bx=color of the player to get its validation pos
                mov bx,cx  
                pop si
                pop cx
                push ax
                mov ax,si 
                mov ch,al
                pop ax
                pusha             
        verticalDown:
                cmp al,7
                jz VP
                inc al
                add di,8
                mov dl,board[di]
                mov dh,0
                mov si ,dx
                Call ispeice          ;dl=1 if peice and dl =0 if not peice     
                cmp dl,0
                jz Helight
                push cx
                Call GetPlayerColor   ; cx=color of the player in this cell
                cmp cx,bx
                jz  NH
                pop cx
                jmp Helight
                NH:
                pop cx
                jmp NotHelight
                Helight:
                mov validateMoves[di],ch
                mov lstValidDirection[0], di    ;for check
                NotHelight:
                cmp dl,1
        jnz verticalDown
                VP:
                popa
                pusha
                
        verticalUP: 
                cmp al,0
                jz  HR
                dec al
                sub di,8 
                mov dl,board[di]
                mov dh,0
                mov si ,dx
                Call ispeice          ;dl=1 if peice and dl =0 if not peice     
                cmp dl,0
                jz Helight1
                push cx
                Call GetPlayerColor   ; cx=color of the player in this cell
                cmp cx,bx
                jz  NH1
                pop cx
                jmp Helight1
                NH1:
                pop cx
                jmp NotHelight1
                Helight1:
                mov validateMoves[di],ch
                mov lstValidDirection[2], di    ;for check
                NotHelight1:
                cmp dl,1
        jnz verticalUP

                HR:
                popa
                pusha

        HorizontalRight:  
                cmp cl,7
                jz HL
                inc cl
                add di,1 
                mov dl,board[di]
                mov dh,0
                mov si,dx
                Call ispeice          ;dl=1 if peice and dl =0 if not peice     
                cmp dl,0
                jz Helight2
                push cx
                Call GetPlayerColor   ; cx=color of the player in this cell
                cmp cx,bx
                jz  NH2
                pop cx
                jmp Helight2
                NH2:
                pop cx
                jmp NotHelight2
                Helight2:
                mov validateMoves[di],ch
                mov lstValidDirection[4], di    ;for check
                     ;========for check
                NotHelight2:
                cmp dl,1
        jnz HorizontalRight

                HL:
                popa
                
                pusha
                
        HorizontalLeft:  
                cmp cl,0
                jz  EndValidate
                dec cl
                sub di,1
                mov dl,board[di]
                mov dh,0
                mov si ,dx
                Call ispeice          ;dl=1 if peice and dl =0 if not peice     
                cmp dl,0
                jz Helight3
                push cx
                Call GetPlayerColor   ; cx=color of the player in this cell
                cmp cx,bx
                jz  NH3
                pop cx
                jmp Helight3
                NH3:
                pop cx
                jmp NotHelight3
                Helight3:
                mov validateMoves[di],ch
                mov lstValidDirection[6], di    ;for check
                
                NotHelight3:
                cmp dl,1
        jnz HorizontalLeft
                EndValidate:
                popa
                popa
                RET
ValidateRook    ENDP 


;========================= chat
;========================= chat
;========================= chat

;_____game chat__________;
InializeChar    PROC
                ;__________ inialize cursor ________;
                mov ah,  0              ;me:cursor => row
                mov al, startCol        ;me:cursor => col
                mov c1, ax

                mov ah,  ChatLineRow    ;you:cursor => row 
                inc ah                  ;ender the line sep bet chat
                mov al, startCol        ;you:cursor => col
                mov c2, ax
                ;__________ print me ________;
                mov dx, c1      ;set cursor
                mov bh, 0
                mov ah, 02
                int 10h

                lea dx, player1    ;print ME:
                mov ah, 9
                int 21h

                ;___________________print YOU_______________________;
                mov dx, c2      ;set cursor
                mov bh, 0       ;page
                mov ah, 02      ;interrupt
                int 10h

                lea dx, player2    ;print YOU:
                mov ah, 9
                int 21h
                ;_____________________update cursors_____________________;
                mov al, startCol
                add al, 3               ;just maragin

                mov ah, 1
                mov c1, ax      ;update cursos to nxt line
                mov ah, ChatLineRow
                add ah, 2
                mov c2, ax      ;update cursos to nxt line
                ;_____________ draw line seperate between chats___________________;
                mov dh, ChatLineRow
                mov dl, startCol       ;lineCol
                mov bh, 0       ;set cusor to line row
                mov ah, 02
                int 10h

                mov al, '_'     ;charcter
                mov bl, 03h     ;color
                mov bh, 0       ;page
                mov ch, 0
                mov cl, rowSize      ;count
                sub cl, startCol
                mov ah, 09      ;repeat count
                int 10h
                ;_____________ draw line___________________;
                mov dh, stausLineRow
                mov dl, startCol     ;lineCol
                mov bh, 0       ;set cusor to line row
                mov ah, 02
                int 10h

                 mov al, '_'     ;charcter
                mov bl, 03h     ;color
                mov bh, 0       ;page
                mov ch, 0
                mov cl, rowSize      ;count
                sub cl, startCol
                mov ah, 09      ;repeat count
                int 10h
                
                RET
InializeChar    ENDP


PrnChar         PROC    ;(dx = cursor position to print) ==> (dx = updated cursor position)
                
                mov bh, 0       ;set cursor position to (dx = cursor position to print)
                mov ah, 02      ;
                int 10h         ;

                mov al, ValueForchat   ;get character to print
                cmp  al, 13     ;check if not enter
                jne prnN        ;if not print it as normal

                add dh, 1
                mov dl, startCol;set cursor col to start col
                mov bh, 0       ;set cursor position to (dx = cursor position to print)
                mov ah, 02      ;
                int 10h         ;
                RET   ;and exit
                ;__________________________________________________;
                
prnN:     
                mov dl, al      ;print character normally
                mov ah, 2
                int 21h

ExPrnChar:      
                mov ah, 3       ;get updated cursor (in dx)
                mov bh, 0
                int 10h

                RET
PrnChar         ENDP


ScrollUP1       PROC           ;dx = cursor poisiotn

                mov ah,6                ; function 6 to scroll up
                mov al,1                ; scroll by 1 line
                mov bh,0                ; normal video attribute = black
                mov ch,1                ; upper left row
                mov cl,startCol         ; upper left col
                mov dh,ChatLineRow      ; lower right row before chat line sep
                dec dh
                mov dl,rowSize          ; lower right col
                int 10h
                RET
ScrollUP1        ENDP

ScrollUP2        PROC    ;dx = cursor poisiotn
                mov ah,6  ; function 6
                mov al,1  ; scroll by 1 line
                mov bh,0  ; normal video attribute

                mov ch,ChatLineRow  ; upper left row after you:
                add ch, 2
                mov cl,startCol  ; upper left col

                mov dh,stausLineRow ; lower right row
                dec dh
                mov dl,rowSize ; lower right col
                int 10h
                RET
ScrollUP2        ENDP


ChkCusrorUpdate PROC
                pusha
chkMeCursor:    mov dx, c1                      ;dx = me cursor
                cmp dh, ChatLineRow             ;chk if in nxt state row = chat line seperator
                jne chkNlCursor1                ;if not chk if enter new col         
                CALL ScrollUP1                  ;else scroll up
                mov dh, ChatLineRow             ;update to be in row before line
                dec dh                          ;
                mov dl, startCol                ;update col to be in start col
                mov c1, dx                      ;mov ValueForchat into cursor
                jmp chkYouCursor                ;chk nxt cursor

chkNlCursor1:   cmp dl, startCol             ;chk if cursor col be less than start col
                jae chkYouCursor             ;if not chk another cursor
                mov dl, startCol             ;else return cursor to start col
                mov c1,dx

chkYouCursor:   mov dx, c2                      ;dx = you cursor
                cmp dh, stausLineRow            ;chk if in nxt state row = status line seperator
                jne chkNlCursor2                ;if not chk if enter new col   
                CALL ScrollUP2                  ;else scroll up
                mov dh, stausLineRow            ;update to be in row before line
                dec dh
                mov dl, startCol                ;update col to be in start col
                mov c2, dx                      ;mov ValueForchat into cursor
                jmp EXITChkCur                  ;and exit function

chkNlCursor2:   cmp dl, startCol             ;chk if cursor col be less than start col
                jae EXITChkCur                ;if not chk another cursor
                mov dl, startCol             ;else return cursor to start col
                mov c2,dx
                     
EXITChkCur:
                popa
                RET
ChkCusrorUpdate ENDP


SendMessage     PROC  FAR

                pusha                           ;send first byte of state
                mov VALUE, PlayerSentMessState
                CALL SEND

                 RcvLp1:  mov dx , 3FDH   ; Line Status Register
                        in al , dx      ;chk if i recived something
                        AND al , 1    
                        cmp al, 1       
                        jne RcvLp1      ;if not continue looping
                        mov dx , 03F8H  ;else get character in al|value
                        in al , dx

                popa

                pusha                   ;send second byte of char  & update cell
                mov ValueForchat, al   ;put character in vluae for SEND call
                mov VALUE, al   ;put character in vluae for SEND call
                CALL SEND       ;send character

                mov dx, c1      ;set me cursor
                CALL PrnChar    ;print character
                mov c1, dx      ;update me cursor
                CALL ChkCusrorUpdate    ;scroll if not
                popa

                RET
SendMessage     ENDP

RcvMessage     PROC  FAR        ;(al = print char)
                pusha

                mov ValueForchat, al
                mov dx, c2      ;set you cursor
                CALL PrnChar    ;print character
                mov c2, dx      ;upate you cursor
                CALL ChkCusrorUpdate

                popa
                RET
RcvMessage     ENDP


;============================================
;============================================
;============================================
;============================================

ValidateBishop  Proc ;al = row cl = col si = player di = cell
                pusha
                mov ax, 0
                mov al, playerCells[si]
                mov di, ax 

                mov al, playerRows[si] 
                mov cl, playerCols[si]
                ; mov al,2
                ; mov cl,5
                ; mov di,21
                push cx
                push si
                mov cl,board[di]
                mov ch,0
                mov si,cx                
                Call GetPlayerColor  ; bx=color of the player to get its validation pos
                mov bx,cx  
                pop si
                pop cx
                push ax
                mov ax,si 
                mov ch,al
                pop ax
                pusha             
        TopLeft:
                cmp al,0
                jz TRt 
                cmp cl,0
                jz TRt 
                dec al 
                dec cl
                sub di,9
                mov dl,board[di]
                mov dh,0
                mov si ,dx
                Call ispeice          ;dl=1 if peice and dl =0 if not peice     
                cmp dl,0
                jz HelightBishop
                push cx
                Call GetPlayerColor   ; cx=color of the player in this cell
                cmp cx,bx
                jz  NHBishop
                pop cx
                jmp HelightBishop
                NHBishop:
                pop cx
                jmp NotHelightBishop
                HelightBishop:
                mov validateMoves[di],ch
                mov lstValidDirection[0], di
                NotHelightBishop:
                cmp dl,1
        jnz TopLeft
                TRt:
                popa
                pusha
                
        TopRight: 
                cmp al,0
                jz  DLt
                cmp cl,7 
                jz  DLt
                dec al
                inc cl
                sub di,7 
                mov dl,board[di]
                mov dh,0
                mov si ,dx
                Call ispeice          ;dl=1 if peice and dl =0 if not peice     
                cmp dl,0
                jz HelightBishop1
                push cx
                Call GetPlayerColor   ; cx=color of the player in this cell
                cmp cx,bx
                jz  NHBishop1
                pop cx
                jmp HelightBishop1
                NHBishop1:
                pop cx
                jmp NotHelightBishop1
                HelightBishop1:
                mov validateMoves[di],ch
                mov lstValidDirection[2], di
                NotHelightBishop1:
                cmp dl,1
        jnz TopRight

                DLt:
                popa
                pusha

        DownLeft:  
                cmp cl,0
                jz DRt
                cmp al,7
                jz DRt
                inc al
                dec cl
                add di,7 
                mov dl,board[di]
                mov dh,0
                mov si,dx
                Call ispeice          ;dl=1 if peice and dl =0 if not peice     
                cmp dl,0
                jz HelightBishop2
                push cx
                Call GetPlayerColor   ; cx=color of the player in this cell
                cmp cx,bx
                jz  NHBishop2
                pop cx
                jmp HelightBishop2
                NHBishop2:
                pop cx
                jmp NotHelightBishop2
                HelightBishop2:
                mov validateMoves[di],ch
                mov lstValidDirection[4], di
                NotHelightBishop2:
                cmp dl,1
        jnz DownLeft

                DRt:
                popa
                
                pusha
                
        DownRight:  
                cmp cl,7
                jz  EndValidateBishop
                cmp al,7 
                jz  EndValidateBishop
                inc cl 
                inc al
                add di,9 
                mov dl,board[di]
                mov dh,0
                mov si ,dx
                Call ispeice          ;dl=1 if peice and dl =0 if not peice     
                cmp dl,0
                jz HelightBishop3
                push cx
                Call GetPlayerColor   ; cx=color of the player in this cell
                cmp cx,bx
                jz  NHBishop3
                pop cx
                jmp HelightBishop3
                NHBishop3:
                pop cx
                jmp NotHelightBishop3
                HelightBishop3:
                mov validateMoves[di],ch
                mov lstValidDirection[6], di
                NotHelightBishop3:
                cmp dl,1
        jnz DownRight
        EndValidateBishop:
                popa
                popa
                RET
ValidateBishop  ENDP 



ValidateKnight Proc FAR                                         ;player 1==>black   ;al = row cl = col si = player di = cell
                              pusha
                             ;CALL GetPlayerColor ;cl = color
                                mov bx,si       ;bl = player number


                                mov al, playerCells[si]
                                mov ah, 0
                                mov di, ax
                                
                                mov al, playerRows[si]
                                mov dl, PlayerCols[si]
                                ;_______________________________;

                                cmp   dl,6
                                jae   mvKn1
                                cmp   al,7
                                je mvKn1
                                mov cl, board[di+10]
                                CALL GetPlayerColorV2   ;get cx = 0 | if not same color
                                                        ;get cx = si| if same color
                                cmp cx,si              ;if not same color jmp
                                jne mvKn1
                                mov   validateMoves[di+10],cl
                                mov lstValidDirection[0], di    ;for check
                                add lstValidDirection[0], 10
                        mvKn1:  cmp   dl,1
                                jbe   mvKn2
                                cmp al, 7
                                je   mvKn2
                                mov cl, board[di+6]
                                CALL GetPlayerColorV2
                                cmp cx,si              ;if not same color jmp
                                jne mvKn2
                                mov   validateMoves[di+6],cl
                                mov lstValidDirection[2], di    ;for check
                                add lstValidDirection[2], 6
                        mvKn2:  cmp   dl, 7
                                je mvKn3
                                cmp al, 6
                                jae mvKn3
                                mov cl, board[di+17]
                                CALL GetPlayerColorV2
                                cmp cx,si              ;if not same color jmp
                                jne mvKn3
                                mov   validateMoves[di+17],cl
                                mov lstValidDirection[4], di    ;for check
                                add lstValidDirection[4], 17
                        mvKn3: cmp dl,0
                                je mvKn4
                                cmp al,6
                                jae mvKn4
                                mov cl, board[di+15]
                                CALL GetPlayerColorV2
                                cmp cx,si              ;if not same color jmp
                                jne mvKn4
                                mov   validateMoves[di+15],cl
                                mov lstValidDirection[6], di    ;for check
                                add lstValidDirection[6], 15
                        mvKn4:  cmp dl,6
                                jae mvKn5
                                cmp al,0
                                je mvKn5
                                mov cl, board[di-6]
                                CALL GetPlayerColorV2
                                cmp cx,si              ;if not same color jmp
                                jne mvKn5
                                mov   validateMoves[di-6],cl
                                mov lstValidDirection[8], di    ;for check
                                sub lstValidDirection[8], 6
                        mvKn5:   cmp dl,1
                                jbe mvKn6
                                cmp al,0
                                je mvKn6
                                mov cl, board[di-10]
                                CALL GetPlayerColorV2
                                cmp cx,si              ;if not same color jmp
                                jne mvKn6
                                mov   validateMoves[di-10],cl
                                mov lstValidDirection[10], di    ;for check
                                sub lstValidDirection[10], 10
                        mvKn6:   cmp dl,7
                                je mvKn7
                                cmp al,1
                                jbe mvKn7
                                mov cl, board[di-15]
                                CALL GetPlayerColorV2
                                cmp cx,si              ;if not same color jmp
                                jne mvKn7
                                mov   validateMoves[di-15],cl
                                mov lstValidDirection[12], di    ;for check
                                sub lstValidDirection[12], 15
                        mvKn7:   cmp dl,0
                                je mvKn8
                                cmp al,1
                                jbe mvKn8
                                mov cl, board[di-17]
                                CALL GetPlayerColorV2
                                cmp cx,si              ;if not same color jmp
                                jne mvKn8
                                mov   validateMoves[di-17],cl
                                mov lstValidDirection[14], di    ;for check
                                sub lstValidDirection[14], 17
                                
                        mvKn8:          popa
                                        RET
ValidateKnight ENDP


ValidateQueen Proc  FAR                                                                 ;al = row cl = col si = player di = cell
                                CALL  ValidateBishop
                                CALL  ValidateRook
                                RET
ValidateQueen ENDP


;VALIDTE KING
;VALIDTE KING
Validatemovetheking PROC FAR ;INPUT DI , PLAYER:SI ,OUTPUT:CL
                PUSH SI
                PUSH AX
                CMP board[DI],emptyCell
                JE HERE;IF EMPTY CELL 
                ;IF NOT EMPTY

                AND SI,1
                SHL SI,3
                ;SI NOW HAVE COLOR OF PLAYER
                MOV AL,BOARD[DI]
                AND AL,8 ;CHECK
                MOV AH,0
                ; NOW AX HAVE COLOR OF PIECE
                CMP AX,SI 
                JE P;IF THEY HAVE SAME COLOR THEN IT ISN'T A VALID MOVE
                HERE:
                POP AX
                POP SI
                PUSH CX
                mov cx,si
                MOV validateMoves[DI],cl
                POP CX
                jmp aw
        p:
        POP AX 
                POP SI
        aw:
ret
Validatemovetheking ENDP 
 
;VALIDTE KING
;VALIDTE KING
ValidateKing    Proc FAR ;al = row cl = col si = player di = cell
        MOV AL,playerRows[SI]
        MOV CL,PlayerCols[SI]
        ;LEFT CELL
        PUSH DI
                CMP CL,1 
                JC GO ;IF COLUMN=0 it'll be negative then it's invalid
                ;IF CARRY NOT 1 THEN IT'S A VALID CELL
                SUB DI,1
                call Validatemovetheking
        ;RIGHT CELL                 
        GO:
        POP DI
        PUSH DI
        PUSH CX
                ADD CL,1
                PUSH BX
                MOV BL,8
                CMP BL,CL
                JE GO1 
                ;IF CL NOT EQUAL 8 THEN WE STILL IN RANGE OF 0 TO 7 COLUMNS --> IT'S A VALID CELL
                add di,1
                call Validatemovetheking        
        ;UP CELL
        GO1:
        POP BX
        POP CX
        POP DI
        PUSH DI
                CMP DI,8
                JC GO2
                ;IF CARRY NOT 1 THEN IT'S A VALID CELL
                sub di,8
                call Validatemovetheking
        ;DOWN CELL    
        GO2:
        POP DI
        PUSH DI
                ADD DI,8
                PUSH BX
                MOV BX,63 ;LAST CELL INDEX
                CMP BX,DI
                JC GO3
                ;IF CARRY NOT 1 THEN IT'S A VALID CELL
                call Validatemovetheking
        GO3:
        POP BX
        POP DI
        ;LEFT UP CELL
        PUSH DI
                CMP CL,1 
                JC GO4 ;IF COLUMN=0 it'll be negative then it's invalid 
                CMP AL,1
                JC GO4 ;IF ROW=0 it'll be negative then it's invalid
                ;IF CARRY NOT 1 THEN IT'S A VALID CELL
                sub di,9
                call Validatemovetheking
        GO4:
        POP DI
        PUSH DI
        ;RIGHT DOWN
        push cx
                ADD CL,1
                PUSH BX
                MOV BL,7
                CMP BL,CL;LAST COLUMN NO RIGHT
                JC GO5
                POP BX
                ADD DI,9
                PUSH BX
                MOV BX,63 ;LAST CELL INDEX
                CMP BX,DI
                JC GO5 ;LAST ROW NO DOWN
                ;IF CARRY NOT 1 THEN IT'S A VALID CELL
                call Validatemovetheking
        GO5:
        POP BX
        pop cx
        POP DI
        PUSH DI
        ;LEFT DOWN
                CMP CL,0 ;first column no left ;;;not working 
                JE GO6
                CMP AL,7
                JE GO6 
                ;NOT LAST ROW
                ADD DI,7
                ;IF CARRY NOT 1 THEN IT'S A VALID CELL
                call Validatemovetheking
                
        GO6: 
        POP DI
        ;RIGHT UP CELL
        PUSH DI
        push cx
                ADD CL,1
                PUSH BX
                MOV BL,7
                CMP BL,CL;LAST COLUMN NO RIGHT
                JC GO7
                CMP AL,1
                JC GO7 ;IF ROW=0 it'll be negative then it's invalid
                ;IF CARRY NOT 1 THEN IT'S A VALID CELL
                sub di,7 
                call Validatemovetheking
        GO7:               
        POP DI
        pop cx
        POP BX
                RET
ValidateKing    ENDP
;================== Player Moves ================;

MoveLeft        PROC FAR;si = player numbers
                cmp PlayerCols[si], 0;check validate move
                je EXITMOVELEFT      ;exit if not

                CALL MvePlayerFromGraphics ;clear highlight of position (si) => di=position of player
                
                sub playerCols[si], 1;update   col
                sub playerCells[si],1;update   cell
                                     ;nochange row 

                shl si, 1;si*2                   ;to get from DataWord ? what bytes to add 2*si   
                sub PlayerPos[si], boardWidth;update player pos

                CALL DrawPlayers  ;(di = playerPos)
EXITMOVELEFT:   RET
MoveLeft        ENDP

MoveRight       PROC FAR;si = player numbers
                cmp playerCols[si], 7;check validate move
                je EXITMOVERIGHT     ;exit if not
                
                CALL MvePlayerFromGraphics ;clear highlight of position (si) => di=position of player
                
                add playerCols[si], 1;update   col
                add playerCells[si],1;update   cell
                shl si, 1;si*2                      ;to get from DataWord ? what bytes to add 2*si 
                add PlayerPos[si], boardWidth   ;update player pos

                CALL DrawPlayers  ;(di = playerPos)
EXITMOVERIGHT:  RET
MoveRight       ENDP ;si = player numbers


MoveUp          PROC FAR;si = player numbers
                cmp playerRows[si], 0;check validate move
                je EXITMOVEUP        ;exit if not
                
                CALL MvePlayerFromGraphics ;clear highlight of position (si) => di=position of player

                sub playerRows[si], 1;update player row
                sub playerCells[si],8;update player cell
                                     ;no change     col
                shl si, 1;si*2
                sub PlayerPos[si], 320*boardWidth

                CALL DrawPlayers ;(di = playerPos)
EXITMOVEUP:     RET
MoveUp          ENDP ;si = player numbers


MoveDown        PROC FAR;si = player numbers
                cmp playerRows[si], 7 ;check validate move
                je EXITMOVEDOWN       ;exit if not
                
                CALL MvePlayerFromGraphics ;clear highlight of position (si) => di=position of player
                
                add playerRows[si], 1;update row
                add playerCells[si],8;update cell
                                     ;nochange col
                shl si, 1;si*2
                add PlayerPos[si], 320*boardWidth

                CALL DrawPlayers  ;(di = playerPos)
EXITMOVEDOWN:   RET
MoveDown        ENDP ;si = player numbers

;================== GAme Logic ================;
ChKTime         PROC    FAR     ;board cell = bx >>> cx=1[can move] | cx=0[can't move]
                push    ax
                push    dx
                push di
                        cmp peiceTimer[bx], 0   ;check if never move
                        je STime                ;if yes return Succes

                        mov ah, 2ch ;cl = min, dh = sec
                        int 21h  

                        mov ax, peiceTimer[bx]  ;ax =  peice time [ah = min, al = sec]
                        cmp cl, ah              ;check if curr min > peice stop min
                        ja STime                ;if (Curr min) > (Stop min) succ & leave
                                                ;else check min
                        sub dh, TmDiff               ;dh = CurrSec - 3 
                        cmp dh, al              ;chk CurrSec-3 >= Stop sec
                        jae STime                ;if true succ & leave
                        mov cx,0                ;else set cx=0 & leave
                        pop di
                        pop dx
                        pop ax
                        RET 

        STime:  mov cx, 1
                pop di
                pop dx
                pop ax
                RET
ChKTime         ENDP
;========================Check============================
ClearMessagePr  PROC    FAR
        pusha
                        mov bh,0       
                        mov dh, 23;row
                        mov dl, 00
                        mov ah, 2
                        int 10h
                        mov di,0
                        printclear2:
                        mov al,Clearcheckmes[di]
                                mov ah, 09h
                                mov bh, 0
                                mov bl, 0fh
                                mov cx, 1
                                int 10h
                                inc dl
                                mov bh, 0;pg number
                                mov dh, 23;row
                                mov ah, 2
                                int 10h
                                inc di
                                cmp Clearcheckmes[di],'$'
                                jnz printclear2    
        popa
                REt
ClearMessagePr  ENDP
PrntChk         PROC    FAR
                mov ah, 0
                or ah, isKingCheck[1]
                or ah, isKingCheck[2]
                cmp ah, 1
                jne clrKng
                pusha
                        mov bh,0       
                        mov dh, 23;row
                        mov dl, 00
                        mov ah, 2
                        int 10h
                        mov di,0
                        printclear1:
                        mov al,checkmes[di]
                                mov ah, 09h
                                mov bh, 0
                                mov bl, 0fh
                                mov cx, 1
                                int 10h
                                inc dl
                                mov bh, 0;pg number
                                mov dh, 23;row
                                mov ah, 2
                                int 10h
                                inc di
                                cmp checkmes[di],'$'
                                jnz printclear1    
                popa
                RET
       clrKng: CALL ClearMessagePr
                RET
PrntChk         ENDP


ClrLstChk       PROC    FAR     ;dx= king cell
                mov lstValidDirection[0], dx
                mov lstValidDirection[2], dx
                mov lstValidDirection[4], dx
                mov lstValidDirection[6], dx
                mov lstValidDirection[8], dx
                mov lstValidDirection[10], dx
                mov lstValidDirection[12], dx
                mov lstValidDirection[14], dx
                ret
ClrLstChk       ENDP


ChecKKing       PROC    ;si = player number
                pusha
                mov bl, playerCells[si] ;bl  to store = playerCell,col,row
                mov cl, PlayerCols[si]
                mov ch, playerRows[si]
                pusha 

                mov cx, 64
                mov di, 0
        tempMv: mov al, validateMoves[di]
                mov validateMovesTemp[di], al
                inc di
                loop tempMv

                CALL ClrHighlightedMvs

                mov al,kingsCells[si]
                mov playerCells[si], al
                mov al,kingsCols[si]
                mov PlayerCols[si], al
                mov al,kingsRows[si]
                mov playerRows[si], al
                mov dl, kingsCells[si]  ;dx = king cell use in clear lstValidMvs
                mov dh, 0
                ;=================chks of pawn =========;
                CALL ClrLstChk
                CALL ValidatePawn

                mov di, lstValidDirection[0]
                mov al, board[di]
                and al, peice
                cmp al, pawn
                je chkdShrt
                mov di, lstValidDirection[2]
                mov al, board[di]
                and al, peice
                cmp al, pawn
                je chkdShrt
                ;=================chks of rook =========;
                CALL ClrLstChk
                CALL ValidateRook

                mov cx, 4
                mov bx, 0
        lpRkCh: mov di, lstValidDirection[bx]
                mov al, board[di]
                and al, peice
                cmp al, rook
                je chkdShrt
                cmp al, queen
                je chkdShrt
                add bx, 2
                loop lpRkCh

                ;=================chks of knight =========;
                CALL ClrLstChk
                CALL ValidateKnight

                mov cx, 8
                mov bx, 0
        lpKnCh: mov di, lstValidDirection[bx]
                mov al, board[di]
                and al, peice
                cmp al, knight
        chkdShrt:        je chked
                add bx, 2
                loop lpKnCh
        
        ;=================chks of bishop =========;
                CALL ClrLstChk

                CALL ValidateBishop
                mov cx, 4
                mov bx, 0
        lpBhCh: mov di, lstValidDirection[bx]
                mov al, board[di]
                and al, peice
                cmp al, bishop
                je chked
                cmp al, queen
                je chked
                add bx, 2
                loop lpBhCh
                
                jmp extChkd

        chked:  mov isKingCheck[si], 1
                jmp extchk2

        extChkd: mov isKingCheck[si], 0 
        extchk2:        popa
                mov playerCells[si], bl
                mov PlayerCols[si], cl
                mov playerRows[si], ch
                ;======== return to validate mvs
                mov cx, 64
                mov di, 0
        tempMv1: mov al, validateMovesTemp[di]
                mov validateMoves[di], al
                inc di
                loop tempMv1
                CALL DrawHighlightedMvs
                
                popa
                CALL PrntChk
                RET
ChecKKing       ENDP


;================================================
SetTime         PROC    FAR     ;board cell = bx
                pusha

                mov ah, 2ch ;cl = min, dh = sec
                int 21h      

                mov ch, cl;ch = min
                mov cl,  dh;cl = sec
                mov peiceTimer[bx], cx;update

                popa
                RET
SetTime         ENDP

SelectValidationOfPeice PROC FAR;si = player number ;
                                ;====== inialize ===;
                                mov   ah, 0
                                mov   al, playerCells[si] ; ax = playerCell
                                mov   di, ax              ; di = playerCell
                                mov   dl, board[di]       ; dl = peiceType                         
                                and   dl, peice         

                                
                                ;======= validation ======;
                                cmp   dl, emptyCell     ;check peice if empty
                                jne   chkPeiceColorVLD  ;if not => check peice color
                                RET                     ;if empty => end function

                                

        chkPeiceColorVLD:       mov   bl, board[di]     ;bl = peice color                   
                                mov   bh, 0             ;bl = peice color
                                and   bl, black         ;bl = peice color
                                push si                 ;store si = [player number]
                                AND SI,1                ;get if player1 or not
                                SHL SI,3                ;if player1 **let si = 8** corresponding to peice color 
                                CMP bx, si              ;compare peice color with si
                                pop si                  ;**restore si for not forgetten
                                je ChkTimePeice         ;if color peice valid => check valid time state
                                RET                     ;else end function

        ChkTimePeice:           mov bx, di              ;bx = cell number             
                                Call ChKTime            ;(bx = cell number) => cx=is valid time state(1,0)
                                cmp cx, 1               ;chk time state
                                je ValidSelectPeice     ;if okay select valid state
                                RET                     ;else exit
                                ;======= validation ======;


        ValidSelectPeice:       mov   playersState[si], playerMoveToChooseAction;update state
                                ;======== store data for later use in ** move peice =========;
                                mov   PlayerSelectedCell[si], al    

                                mov   al, playerRows[si]       
                                mov   PlayerSelectedRow[si], al  

                                shl   si, 1 
                                mov   ax, playerPos[si]           
                                mov   PlayerSelectedPos[si], ax           
                                shr si, 1 
                                ;======== store data for later use in ** move peice =========;

        chkPawn:                cmp   dl, pawn          ;chk peice
                                jne   chkRook           ;if not jump to next peice
                                CALL  ValidatePawn      ;else call proper function
                                jmp   exitSelectValidate;and jmp to the end of function
        chkRook:                cmp   dl, rook          ;chk peice
                                jne   chkKnight
                                CALL  ValidateRook
                                jmp   exitSelectValidate;and jmp to the end of function
        chkKnight:              cmp   dl, knight        ;chk peice
                                jne   chkBishop
                                CALL  ValidateKnight
                                jmp   exitSelectValidate;and jmp to the end of function
        chkBishop:              cmp   dl, bishop        ;chk peice
                                jne   chkQueen
                                CALL  ValidateBishop
                                jmp   exitSelectValidate;and jmp to the end of function
        chkQueen:               cmp   dl, queen         ;chk peice
                                jne   chkKing
                                CALL  ValidateQueen
                                jmp   exitSelectValidate;and jmp to the end of function

        chkKing:                CALL  ValidateKing      ;if no other then chk king
exitSelectValidate:
                                ;======== update graphics **highlight available moves =========;
                                CALL DrawHighlightedMvs
RET
SelectValidationOfPeice ENDP


AddCellToWait   PROC FAR                ;si
                pusha
                mov al, playerCols[si]
                mov ah, playerRows[si]
                mov bl, tailTimeArray  
                mov bh, 0 
                mov timerArray[bx], ax
                add tailTimeArray, 2
                cmp tailTimeArray, 68;34*2
                jne extAddCell
                mov tailTimeArray, 0
        extAddCell:
                 ;====================
                mov al, 30h
                shl si, 1
                mov di, playerPos[si]
                CALL DrawSquareBordSm

                ;==================== 
                popa
                RET
AddCellToWait   ENDP


ClrCharInStPos  PROC    FAR ;(di = startPos; al = rows; si = cell)
                      push ax
                        ;=========== get color of cell that player stand on =====;
                               push bx
                                mov bx, si              ;bl = cell
                                add bl, al              ;bl= row + cell
                                and bl, 1               ;if odd => cell color index 1 
                                mov bh, 0               ;if even=> cell color index 0
                                mov al, color[bx]       ;load color
                                pop bx
                        ;=========== get color of cell that player stand on =====;
                        CALL DrawSquareBordSm
                        pop ax
                RET
ClrCharInStPos  ENDP

;delete if not
UpdateCellWait  PROC    FAR
                pusha
        loopOnWaitCell: 
                mov al, headTimeArray
                cmp al, tailTimeArray   ;if head = tail => mean empty 
                je EXITUpdateCellWait   ;if exit
                mov ah, 0
                mov si, ax   ;si = index of curr [r, c] time array
                mov cx, timerArray[si]  ;ch=row, cl =col
                mov al, ch              ;
                mov di,cx
                CALL RowColToCell       ;(al = row, cl = col) =>si = cell number
                mov bx, si              ;
                push cx
                CALL ChKTime            ;board cell = bx >>> cx=1[can move] | cx=0[can't move]
                cmp cx, 1               ;chk if can move
                pop cx
                jne EXITUpdateCellWait  ;if can't mov
                mov cx,di
                mov al,ch
                CALL RowColToStartPos   ;al =row    cl=col   =>di=StartPos
                CALL ClrCharInStPos
                ;;;=========== call graphics ==============;;;
                
                add headTimeArray, 2    ;delete by update head
                cmp headTimeArray, 68   ;if head overflow return to 0
                jmp loopOnWaitCell      ;if not continue without update head for overflow
                mov headTimeArray, 0    ;update for overflow
                jmp loopOnWaitCell       ;
       
                EXITUpdateCellWait:
                popa
                RET
UpdateCellWait  ENDP







SendMoveToAnotherPlayer PROC FAR
                        pusha

                        mov al, PlayerSelectedCell[si]
                        mov VALUE, al
                        CALL SEND

                RcvLp:  mov dx , 3FDH   ; Line Status Register
                        in al , dx      ;chk if i recived something
                        AND al , 1    
                        cmp al, 1       
                        jne RcvLp      ;if not continue looping
                        mov dx , 03F8H  ;else get character in al|value
                        in al , dx

                        mov al, playerCells[si]
                        mov VALUE, al
                        CALL SEND

                        popa
                        RET
SendMoveToAnotherPlayer ENDP


MovePeiceFromTo PROC    FAR ;si = playerNumber
                pusha
                ;=========== check if move validate =========;
                mov bh, 0
                mov bl, playerCells[si]     ;bx = player cell
                mov ax, si                  ;get valid state of cell
                cmp validateMoves[bx], al   ;chk if one of valid moves of player
                je startMvePeiceF
                CALL ClrHighlightedMvs      ;if not exit
                mov playersState[si], playerMoveToChoosePeice
                popa
                RET


                ;======= handel communication
                startMvePeiceF: 
                CALL SendMoveToAnotherPlayer
                ;======= handel communication
                CALL AddPeiceToAnimationQueue
                ;======= handel move cell **from  ======;
             ;out==>bl = cell
                ;== Logically
                mov bl, PlayerSelectedCell[si]
                mov bh, 0
                mov peiceTimer[bx], 0         ;return time state of cell
                

                ;======= handel move cell **to  ======;
                ;== hande if pawn and about to promote
                
                ;== Logically
                CALL SetTime                    ;(bx = cell) => peiceTime[bx] = curr time
                CALL AddCellToWait
                CALL ClrHighlightedMvs
                mov playersState[si], playerMoveToChoosePeice
                popa
                RET
MovePeiceFromTo ENDP



CellToRowCol            PROC FAR        ;al = cell => al = row , cl = col
                        mov ah, 0
                        mov bh, 8
                        DIV bh          ;al = q = row
                                        ;ah = rem = col
                        mov cl, ah
                        RET
CellToRowCol            ENDP 


UpdateAnotherPlayer     PROC FAR  
                        pusha
                        ;======= player from
                        mov al,from_against_player
                        mov PlayerSelectedCell[si],al
                        Call CellToRowCol          ;
                        Call RowColToStartPos      ;al =row    cl=col   =>di=StartPos
                        mov PlayerSelectedRow[si],al
                        shl si, 1
                        mov PlayerSelectedPos[si],di
                        shr si, 1
                        ;====== player to
                        mov al,to_against_player
                        mov playerCells[si],al
                        Call CellToRowCol
                        Call RowColToStartPos      ;al =row    cl=col   =>di=StartPos
                        mov playerRows[si], al
                        mov playerCols[si], cl
                        shl si, 1
                        mov playerPos[si],di
                        shr si, 1
                        popa
                        RET
UpdateAnotherPlayer     ENDP



MovePeiceFromToAnotherPlayer PROC    FAR ;si = playerNumber
                pusha
                
                ;=========== check if move validate =========;
                CALL UpdateAnotherPlayer
                mov bh, 0
                mov bl, playerCells[si]     ;bx = player cell
                ;======= handel move cell **from  ======;
                ;== Graphically
                CALL MvePieceFromGraphics 
                ;out==>bl = cell
                ;== Logically
                mov bh, 0
                mov al, board[bx]             ;*********** al = peice that should move
                mov board[bx], emptyCell      ;set empty cell
                

                ;======= handel move cell **to  ======;
                ;== hande if pawn and about to promote
                mov dl, al      ;copy peice 
                and dl, 7       ;get peice  type only
                cmp dl, pawn    ;chk if pawn
                jne skpPwnR      ;if not pawn skip
                cmp playerRows[si], 0        ;if first row 
                je  PrmPwnR
                cmp playerRows[si], 7        ; or last row
                jne skpKngR                   ;he is pawn so skip king
        PrmPwnR: or al, 4        ;transfer peice to queen by set third bit
                jmp skpKngR
        skpPwnR: cmp dl, king    ;chk if king
                jne skpKngR
                mov ah, playerCells[si]
                mov kingsCells[si], ah

                mov ah, playerCols[si]
                mov kingsCols[si], ah

                mov ah, playerRows[si]
                mov kingsRows[si], ah
                ;== Graphically
        skpKngR: CALL MvePieceToGraphics      ;out ===> bx = cell
                ;== Logically
                mov dl, board[bx]               ;get peice type that killed
                and dl, peice
                cmp dl, king                    ;chk if king
                jne skipKingDeadR
                mov playersState[si], PlayerWin ;if king win
                xor si, 3           ; to toggle the player number to change states
                mov playersState[si], PlayerLose
                xor si, 3           ;to return the number of the player again
                mov isGameEnded, 1
        skipKingDeadR:        mov board[bx], al
                cmp isGameEnded, 1
                jne chngStateR
                popa
                RET
        chngStateR:
                ;========== check for checkmate
                mov si, PlayerGameNumber       ;black moved => mov peice then check check another player
                Call ChecKKing
               
                popa
                RET
MovePeiceFromToAnotherPlayer ENDP

;================= timer =====================;

PrntNumber      PROC ;bh = cell, dl = col
        pusha
        mov ah,0 
        mov al,bh    ;al = bh
        mov bh,10    ;num/10 
        div bh       ;ah= Rem => second digit 
                     ;al= Quo => first digit
        or ax, 3030h ;get ascii

        ;======= print min ========;
        pusha
                mov bh, 0;pg number
                mov dh, 24;row
                mov ah, 2
                int 10h
        popa
        inc dl
        pusha
                mov ah, 09h
                mov bh, 0
                mov bl, 0fh
                mov cx, 1
                int 10h

        popa

        ;======= print sec ========;
        pusha
                mov bh, 0;pg number
                mov dh, 24;row
                mov ah, 2
                int 10h
        popa
        pusha
                mov al, ah
                mov ah, 09h
                mov bh, 0
                mov bl, 0fh
                mov cx, 1
                int 10h

        popa

      

        

POPA

RET
PrntNumber      ENDP


GetCurrTime     PROC    FAR ;
                pusha
               
                mov ah, 2ch ;cl = min, dh = sec
                int 21h      
                
                sub dh, startSec;dh - start_sec
                jnc SubMn1      ;chk if carry
                add dh, 60      ;if it take 60sec from mins
                sub cl, 1       ;and add dec one min 

        SubMn1: sub cl, StartMin;subtract min
        
                cmp cl, GameMin;chk it time not ended
                jl  ContG      ;if not ended continue
                mov playersState[playerNum1], PlayerLose
                mov playersState[playerNum2], PlayerLose
                mov isGameEnded, 1
                popa
                RET
        ContG:  mov ah, GameMin
                mov al, GameSec

                sub al, dh 
                jnc SubMn2
                add al, 60
                sub ah, 1  ;al = sec
        SubMn2:
                sub ah, cl ;ah = min


                mov bh, ah
                mov dl, 75
                CALL PrntNumber

                 ;======= print column ========;
                pusha
                        mov bh, 0;pg number
                        mov dh, 24;row
                        mov dl, 77
                        mov ah, 2
                        int 10h
                popa
                pusha
                        mov al, ':'
                        mov ah, 09h
                        mov bh, 0
                        mov bl, 0fh
                        mov cx, 1
                        int 10h

                popa

                mov bh, al
                mov dl, 78
                CALL PrntNumber

                ;====== print ========
                popa
                REt
GetCurrTime     ENDP            


;==========================================================================;
;==========================================================================;
;==========================================================================;
;==========================================================================;
;==========================================================================;
;================================GAME======================================;
;==========================================================================;
;==========================================================================;
;==========================================================================;
;==========================================================================;
;==========================================================================;
;==========================================================================;
;if i win
PrntMsgWIN1         PROC FAR ;bx = offset of message
        pusha
                CALL ClearMessagePr
                mov di,0
                mov dl, 0
                printPV31:
                        ;dl = current col
                        mov bh, 0;pg number     ;set cursor
                        mov dh, 23;row
                        mov ah, 2
                        int 10h
                        
                        mov al,player1[di]
                        mov ah, 09h     ;print character
                        mov bh, 0       ;page
                        mov bl, 04h     ;bl = color
                        mov cx, 1
                        int 10h

                        inc dl         
                        inc di
                        cmp player1[di],'$'
                        jne printPV31

                mov di, 0
                printPV3:
                        ;dl = current col
                        mov bh, 0;pg number     ;set cursor
                        mov dh, 23;row
                        mov ah, 2
                        int 10h
                        

                        mov al,player1WinMess[di]
                        mov ah, 09h     ;print character
                        mov bh, 0       ;page
                        mov bl, 04h     ;bl = color
                        mov cx, 1
                        int 10h

                        inc dl         
                        inc di
                        cmp player1WinMess[di],'$'
                        jne printPV3
                popa
                RET
PrntMsgWIN1         ENDP


PrntMsgWIN2         PROC FAR ;bx = offset of message
        pusha
                CALL ClearMessagePr
                mov di,0
                mov dl, 0
                printPV41:
                        ;dl = current col
                        mov bh, 0;pg number     ;set cursor
                        mov dh, 23;row
                        mov ah, 2
                        int 10h
                        
                        mov al,player1[di]
                        mov ah, 09h     ;print character
                        mov bh, 0       ;page
                        mov bl, 04h     ;bl = color
                        mov cx, 1
                        int 10h

                        inc dl         
                        inc di
                        cmp player1[di],'$'
                        jne printPV41

                mov di, 0
                printPV4:
                        ;dl = current col
                        mov bh, 0;pg number     ;set cursor
                        mov dh, 23;row
                        mov ah, 2
                        int 10h
                        

                        mov al,player2WinMess[di]
                        mov ah, 09h     ;print character
                        mov bh, 0       ;page
                        mov bl, 04h     ;bl = color
                        mov cx, 1
                        int 10h

                        inc dl         
                        inc di
                        cmp player2WinMess[di],'$'
                        jne printPV4
                popa
                RET
PrntMsgWIN2         ENDP


PrntExt         PROC FAR ;bx = offset of message
pusha
                mov di,0
                mov dl, 0
                printPV5:
                        ;dl = current col
                        mov bh, 0;pg number     ;set cursor
                        mov dh, 24;row
                        mov ah, 2
                        int 10h
                        

                        mov al,prntExitMess[di]
                        mov ah, 09h     ;print character
                        mov bh, 0       ;page
                        mov bl, 0fh     ;bl = color
                        mov cx, 1
                        int 10h

                        inc dl         
                        inc di
                        cmp prntExitMess[di],'$'
                        jne printPV5
                popa
                RET
PrntExt         ENDP


ENDgameWin      PROC      FAR   

                mov si, PlayerGameNumber
                cmp playersState[si], PlayerWin
                jne plyer2WIN
                CALL PrntMsgWIN1
                mov playerWinGame, 1
                jmp WtTillExt

        plyer2WIN: CALL PrntMsgWIN2
                   mov playerWinGame, 2

        WtTillExt:      CALL PrntExt
        lpWtTil:        mov ah, 1
                        int 16h
                        jz chkExitRcv

                        mov ah, 0
                        int 16h
                        cmp ah,3Eh
                        je ExitWaitSend
                        
                chkExitRcv:
                        mov dx , 3FDH   ; wait till second character
                        in al , dx      ; 
                        AND al , 1    
                        cmp al, 1       
                        jne lpWtTil  

                        mov  dx , 03F8H  ;else get character in al|value
                        in al , dx  
                        cmp al,3Eh
                        jne lpWtTil
                        RET
                        
                ExitWaitSend:   mov VALUE, ah
                                CALL SEND
                                RET
                RET
ENDgameWin      ENDP


ControllGame    PROC FAR        ;si, ax = value
        pressUp:    
                        cmp ah, 48h
                        jne pressLeft
                        CALL MoveUp
                        jmp ExitControllGame

        pressLeft:      cmp ah, 4bh
                        jne pressDown
                        Call MoveLeft
                        jmp ExitControllGame

        pressDown:      cmp ah, 50h  
                        jne pressRight
                        CALL MoveDown
                        jmp ExitControllGame

        pressRight:     cmp ah, 4dh
                        jne pressZero
                        CALL MoveRight
                        jmp ExitControllGame
        pressZero:              cmp   ah, 'R'
                                jne   chkF4
                                cmp   playersState[si], playerMoveToChoosePeice
                                jne   stateLabel2
                                CALL  SelectValidationOfPeice
                                jmp   ExitControllGame
        stateLabel2:            cmp   playersState[si], playerMoveToChooseAction
                                jne   chkF4
                                CALL  MovePeiceFromTo
                                Call ChecKKing
                                jmp   ExitControllGame
                chkF4:          cmp ah,3Eh      ;chk if clik f4
                                jne sndChar
                                mov playersState[si], PlayerEndedGame
                                mov isGameEnded, 2
                                MOV VALUE, PlayerClkF4
                                CALL SEND
                                jmp ExitControllGame
                sndChar:        CALL SendMessage
                ExitControllGame:
                RET
ControllGame    ENDP        ;si, al = value


StartGame PROC FAR

        ; ____ inialize video mode ____;
        mov      ax, 0a000h                        ;for inline drawing
        mov      es, ax
        mov ax, 0003h                                  ; clear screen
        int 10H
        mov      ax, 0013h                         ; to video mode
        int      10h
        ; ____ inialize video mode ____;
        
        CALL DrawBoard                          ;inialize draw board
        CALL InializeChar
        ;==== inialize timer
        mov ah, 2ch
        int 21h
        mov StartMin, cl
        mov StartSec, dh
        

MAIN_LOOP:
noActGM:        
         cmp isGameEnded, 1
         jb ContGame            ;if blew one => not ended by player or kings
         cmp isGameEnded, 1
         jne finishGame
         CALL ENDgameWin
        finishGame: CALL EndGameState
        RET
        ;================= Continue Game ================;
        
ContGame:
        CALL UpdateCellWait
        CALL GetCurrTime
        CALL StartAnimation
                ;===== send
                mov ah, 1
                int 16h
                jz recieveletter
                mov ah, 0
                int 16h
                mov si, PlayerGameNumber
                CALL ControllGame
                ;===========Recieve from the othe player========;
        recieveletter:    
                mov dx , 3FDH   ; Line Status Register
                in al , dx      ;chk if i recived something
                AND al , 1    
                cmp al, 1       
                jne MAIN_LOOP      ;if not continue looping

                mov  dx , 03F8H  ;else get character in al|value
                in al , dx                      
                cmp al, PlayerClkF4             ;chk if exit
                jne chkForChat                  ;if not store from cell
                mov isGameEnded, 2              ;else exit end game
                jmp MAIN_LOOP                   ;and return to main loop
        chkForChat:     cmp al, PlayerSentMessState        ;chk if p 
                        jne storeFromCellAnotherPlayer
                        mov VALUE, 1
                        CALL SEND
                        lppp1:   mov dx , 3FDH   ; wait till second character
                                in al , dx      ; 
                                AND al , 1    
                                cmp al, 1       
                                jne lppp1
                        mov  dx , 03F8H  ;else get character in al|value
                        in al , dx
                        CALL RcvMessage
                        jmp MAIN_LOOP

        storeFromCellAnotherPlayer:
                mov from_against_player,al
                mov VALUE, 1
                CALL SEND
                

        lppp:   mov dx , 3FDH   ; wait till second character
                in al , dx      ; 
                AND al , 1    
                cmp al, 1       
                jne lppp  

                mov  dx , 03F8H  ;else get character in al|value
                in al , dx   

                mov to_against_player,al
                mov si,PlayerGameNumber ;get player number
                xor si,3
                Call MovePeiceFromToAnotherPlayer

                jmp MAIN_LOOP
                ;==================== start move another player
                ;==================== start move another player
                

                jmp MAIN_LOOP
StartGame ENDP
;_______ inialize board ___________;  


;; [move => cell] XOR validateMoves[cell], player

END 
 

